*-----------------------------------------------------------
* Title      :Group A Guy Deconstructor
* Written by :Daniel Lorentz, Martin Chow, Dale Berg
* Date       :12/5/20
* Description:
*-----------------------------------------------------------
    ORG    $1000
START:                  ; first instruction of program

    MOVEA.L #$00005000,A1
    MOVE.L  #$00005000,io_start
    *MOVE.W ,intput_end
    MOVE.W  #$4E71,(A1)+        ;NOP
    MOVE.W  #$4E75,(A1)+        ;RTS
    MOVE.L  #$D07C4000,(A1)+        ;ADD
    MOVE.L  #$D2FC0020,(A1)+        ;ADDA
    MOVE.W  #$5A00,(A1)+        ;ADDQ
    MOVE.W  #$9CD4,(A1)+        ;SUB
    MOVE.W  #$1200,(A1)+        ;MOVE
    MOVE.L  #$327C0500,(A1)+        ;MOVEA
    MOVE.W  #$7E49,(A1)+        ;MOVEQ
    MOVE.L  #$48910001,(A1)+        ;MOVEM
    MOVE.L  #$60000036,(A1)+        ;BRA
    MOVE.L  #$C47C0001,(A1)+        ;AND
    MOVE.W  #$ED00,(A1)+        ;ASL
    MOVE.W  #$E200,(A1)+        ;ASR
    MOVE.W  #$E508,(A1)+        ;LSL
    MOVE.W  #$E308,(A1)+        ;LSR
    MOVE.W  #$E99B,(A1)+        ;ROL
    MOVE.W  #$EA9B,(A1)+        ;ROR
    MOVE.W  #$4E91,(A1)+        ;JSR
    MOVE.W  #$45F9,(A1)+        ;LEA
    MOVE.L  #$DC00FF00,(A1)+        ;LEA PT 2
    MOVE.W  #$BA13,(A1)+        ;CMP
    MOVE.W  #$67FC,(A1)+        ;BEQ
    MOVE.W  #$6EFA,(A1)+        ;BGT
    MOVE.W  #$6FF8,(A1)+        ;BLE
    *MOVEA.L #$00006032,A1
    MOVE.L  #$0000503A,io_end


*----------------------Dale Code--------------------------------
   LEA      starting_prompt,A1
   MOVE.B   #14,D0
   TRAP     #15
   LEA      new_line,A1
   MOVE.B   #14,D0
   TRAP     #15
   LEA      new_line,A1
   MOVE.B   #14,D0
   TRAP     #15

   ADDI.B   #$2,D3          * add two to io counter

MAIN_PROCESS
   LEA       start_address_msg,A1  * load start address prompt

   CMPI.B   #$2,D3
   BEQ      INPUT_TO_HEX

   CMPI.B   #$1,D3               * check if we are at first stage of io
   BEQ      PUT_START_IN_MEMORY   * if we are, then process user input for start address

   CMPI.B   #$0,D3                * otherwise, process user input for end address
   BEQ      PUT_END_IN_MEMORY

INPUT_TO_HEX
   CMPI.B   #$0,D3
   JSR      LOAD_END_ADDR * load end address message

   MOVE.B   #14,D0
   TRAP     #15
   MOVEA.W  init_addr,A1 * store at 6000, an arbitrary memory address

   SUB.B    #$1,D3 * remove one from io counter

   MOVE.W   #2,D0 * trap 2 to read inout from keyboard
   TRAP     #15
   MOVE.B   #0,D0 * display the input
   TRAP     #15

   CLR.L    D6     * clear out D6 for input
   ADD.W    D1,D6  * make copy of the size to decrement loop in memory (might not need this)
   MOVEA.L  A1,A2  * copy the value at A1 to A2

   CMPI.L    #$8,D1 * ensure user input is an 8 byte address
   BNE       UNSUPPORTED_CHARACTER * if it isn't then show invalid message and repeat process

   JMP       ENSURE_VALID * check if user input is allowed

UNSUPPORTED_CHARACTER
   ADDI.B   #$1,D3          * increment io loop to go back a step
   LEA      not_valid,A1    * load invalid input message
   MOVE.B   #14,D0          *
   TRAP     #15             *
   JMP      MAIN_PROCESS    * branch back to main process to try again

ENSURE_VALID
   CMP.W   #$0,D6           * all elements of input have been processed
   BEQ      MAIN_PROCESS    * if so, branch back to main

   CLR.L    D2              * clear out D2
   MOVE.B   (A1),D2         * move byte A1 points to to D2

   CMPI.W    #$0020,D2      * do comparisons
   BMI.S     UNSUPPORTED_CHARACTER

   CMP.B     smallest_letter,D2  * check if within bounds of smallest allowed letter
   BGT       VERIFY_LETTER   * if so, branch to letter processing

   CMP.B     min_size,D2     * check if input is too small to be valid
   BLT       UNSUPPORTED_CHARACTER        * if so, it is invalid

   JMP       IS_NUMERIC          * we know it's a number at this point

VERIFY_LETTER
   CMP.B     invalid_sixty_six,D2
   BGT       UNSUPPORTED_CHARACTER

   CMP.B     invalid_sixty,D2
   BGT       VERIFIED_LETTER_LOWERCASE

   CMP.B     max_letter_size_uppercase,D2        * Only allow capitols, it's a letter (move this to a const)
   BLT       VERIFIED_LETTER_UPPERCASE         * It's within bounds of upper case letter

   CMP.B     max_letter_size_uppercase,D2  * (move this to a const)
   BGT       UNSUPPORTED_CHARACTER        * too big to be valid

IS_NUMERIC
   CMP.B    max_number_value,D2
   BGT      UNSUPPORTED_CHARACTER

   CMP.B    #$000,D2
   BLT      UNSUPPORTED_CHARACTER

   SUB.B    #$1,D6

   SUB.B    #$30,(A1)+
   JMP      ENSURE_VALID

VERIFIED_LETTER_UPPERCASE
   SUB.B   #$37,(A1)+      * transform from ascii to hex
   SUB.B   #$1,D6          * decrement one from size (do we need D^ for this?)
   JMP     ENSURE_VALID         * branch back to bounds

VERIFIED_LETTER_LOWERCASE
   SUB.B    #$57,(A1)+      * transform from ascii to hex
   SUB.B    #$1,D6          * decrement one from size (do we need D^ for this?)
   JMP      ENSURE_VALID    * branch back to bounds

PUT_START_IN_MEMORY
   JSR       SETUP_STORAGE
   MOVE.L    (a3),io_start * move content of A3 to input start variable
   JMP       INPUT_TO_HEX  * branch back to conversion loop

PUT_END_IN_MEMORY
   JSR      SETUP_STORAGE
   MOVE.L   (a3),io_end  * move end address to io_end variable
   JMP      OPSETUP * this is where we should jump to next stage

PROCESS_INPUT
   CLR.L    d7
   ADDI.B   #$4,d7

INCREMENT_PROCESS
   SUB.L    #$1,d7
   JMP      PROCESS_INPUT_LOOP
   RTS

PROCESS_INPUT_LOOP
   CMP.B    #$0,d7
   BEQ      RETURN_FROM_PROCESS
   JSR      BIT_SHIFTING
   JSR      INCREMENT_PROCESS

BIT_SHIFTING
   CLR.L    D1
   MOVE.B   (A2)+,d1
   MOVE.B   D1,D4

   ASL.L    #$04,D4
   TST.L    D4
   SEQ.B    D1
   ADD.B    (A2)+,D4
   MOVE.B   D4,(A4)+
RTS

RETURN_FROM_PROCESS
   RTS  * This is the only way to leave the process loop

SETUP_STORAGE
   MOVEA.L   A2,a4           *
   MOVEA.L   A2,a3           *
   JSR      PROCESS_INPUT
   MOVE.L    (a3),d5         *
   RTS

LOAD_END_ADDR
   LEA       end_address_msg,A1 * load the leaving message
   RTS


OPSETUP
    MOVEA.L io_start,A5
    MOVEA.L io_end,A6
    *SUB.L   #$16,A6

    JMP     PRIMELOOP

PRIMELOOP
    JSR     CHECK_PAGE_SIZE
*----CHECK IF AT END OF MEMORY TO DECODE----
    CMPA.L  A6,A5
    BGT     ENDPROGRAM      ;WILL WRITE LATER
    
*---------------------print address, by Marint------

    MOVE.L  A5,D1
    MOVE.B  #15,D0
    MOVE    #16,D2
    TRAP    #15
    JSR     printTAP

*--------------------------------
    
    MOVE.W  (A5)+,D7        ;MOVE NEXT WORD TO D7

    MOVE.W  D7,D6           ;MOVE COPY OF D7 TO D6 TO MANIP
    AND.W   #$C000,D6          ;CLEAR ALL BUT FIRST TWO BITS
    ROL.W   #2,D6           ;MOVE FIRST TWO BITS TO END

*----CHECK FIRST BITS FOR SUBROUTINES----
    CMP.B   #%00,D6         ;IF FIRST BITS 00
    BEQ     ZEROZERO

    CMP.B   #%01,D6         ;IF FIRST BITS 01
    BEQ     ZEROONE

    CMP.B   #%10,D6         ;IF FIRST BITS 10
    BEQ     ONEZERO

    CMP.B   #%11,D6         ;IF FIRST BITS 11
    BEQ     ONEONE

    JMP     PRINT_DATA

*--------------------------------------------
*CONFIRMS IF THE NUMBER OF LINES ALREADY ON PAGE <29
*IF >=30, WAIT FOR KEY INPUT TO CONTINUE
*D7 = ORIGINAL WORD OF MEMORY
CHECK_PAGE_SIZE
    ADD.B   #1,CURRPAGE
    MOVE.B  CURRPAGE,D4
    CMP.B   #29,D4
    BGE     WAIT_FOR_PAGE

    RTS

*--------------------------------------------
*IF PAGE SIZE >=29, WAIT FOR KEY INPUT TO CONTINUE
*D7 = ORIGINAL WORD OF MEMORY
WAIT_FOR_PAGE
    LEA     MESSAGE_CONTINUE,A1
    MOVE.B  #14,D0
    TRAP    #15

    MOVE.B  #5,D0
    TRAP    #15

    MOVE.B  #$0,CURRPAGE

    JMP     PRIMELOOP

*--------------------------------------------
*MOVE & MOVEA
*D7 = ORIGINAL WORD OF MEMORY
ZEROZERO
*----SETUP----
    MOVE.W  D7,D6
    AND.W   #$01C0,D6       ;CLEAR ALL BUT BITS 8-6
    LSR.W   #6,D6           ;MOVE BITS 8-6 TO 2-0

*----MOVEA----
    CMP.B   #01,D6
    BEQ     PROCESS_MOVEA

*----MOVE----
    BRA     PROCESS_MOVE    ;ALL OTHERS ARE MOVE

    JMP     PRINT_DATA

*--------------------------------------------
*NOP, MOVEQ, MOVEM, ADDQ, LEA, NOT, BCC, JSR, & RTS
*D7 = ORIGINAL WORD OF MEMORY
ZEROONE
*---------NOP------------
    CMP.W   #$4E71,D7
    BEQ     PRINT_NOP       ;OUTPUT NOP

*--------RTS------------
    CMP.W   #$4E75,D7
    BEQ     PRINT_RTS       ;OUTPUT RTS

*-----SETUP BITS 13-12-----
    MOVE.W  D7,D6           ;COPY ORIGINAL TO D6
    AND.W   #$3000,D6       ;CLEAR ALL BUT BITS 13-12
    ROL.W   #4,D6           ;MOVE BITS 13-12 TO 1-0

*CHECK FOR SECONDARY SUBROUTINES OR PROCESS SUB
    CMP.B   #%00,D6
    BEQ     ZEROONE_SECONDARY_BRANCH    ;FOR MOVEM, LEA, NOT, JSR

    CMP.B   #%01,D6
    BEQ     PROCESS_ADDQ    ;ADDQ

    CMP.B   #%10,D6
    BEQ     PROCESS_BCC     ;BCC & BRA

    CMP.B   #%11,D6
    BEQ     PROCESS_MOVEQ   ;MOVEQ

    JMP     PRINT_DATA


*--------------------------------------------
*SECONDARY BRANCH SUBROUTINE FOR ZEROONE
*MOVEM, LEA, NOT, & JSR
*D7 = ORIGINAL WORD OF MEMORY
ZEROONE_SECONDARY_BRANCH
*---CHECK FOR JSR----
    MOVE.W  D7,D6
    AND.W   #$0FC0,D6    ;CLEAR ALL BUT BITS 11-6
    LSR.W   #6,D6       ;MOVE BITS 11-6 TO 5-0
    CMP.B   #$3A,D6
    BEQ     PROCESS_JSR ;JSR

*---CHECK FOR NOT-----
    MOVE.W  D7,D6
    AND.W   #$0F00,D6    ;CLEAR ALL BUT BITS 11-8
    LSR.W   #8,D6       ;MOVE BITS 11-8 TO 3-0
    CMP.B   #$6,D6
    BEQ     PROCESS_NOT ;NOT

*---CHECK FOR LEA----
    MOVE.W  D7,D6
    AND.W   #$01C0,D6    ;CLEAR ALL BUT BITS 8-6
    LSR.W   #6,D6       ;MOVE BITS 8-6 TO 2-0
    CMP.B   #$7,D6
    BEQ     PROCESS_LEA ;LEA

*---CHECK FOR MOVEM---
    MOVE.W  D7,D6
    AND.W   #$0380,D6    ;CLEAR ALL BUT BITS 9-7
    LSR.W   #7,D6       ;MOVE BITS 9-7 TO 2-0
    CMP.B   #$1,D6
    BEQ     MOVEM_BUFF   ;MOVEM

    JMP     PRINT_DATA

*--------------------------------------------
*MOVEM BUFFER FOR CODE INTEGRATION
*D7 = ORIGINAL WORD OF MEMORY
MOVEM_BUFF
    JSR     MOVEMfunc

    JMP     PRIMELOOP

*--------------------------------------------
*SUB, & OR
*D7 = ORIGINAL WORD OF MEMORY
ONEZERO
*---SETUP----------
    MOVE.W  D7,D6
    AND.W   #$3000,D6
    ROL.W   #4,D6

*---CHECK FOR OR---
    CMP.B   #0,D6
    BEQ     PROCESS_OR

*---CHECK FOR SUB--
    CMP.B   #1,D6
    BEQ     PROCESS_SUB

    JMP     PRINT_DATA


*--------------------------------------------
*ADD, ADDA, AND, LSL/LSR, ASL/ASR, & ROL/ROR
*D7 = ORIGINAL WORD OF MEMORY
ONEONE
*---SETUP----------
    MOVE.W  D7,D6
    AND.W   #$3000,D6
    ROL.W   #4,D6

*CHECK FOR ADD & ADDA--
    CMP.B   #$1,D6
    BEQ     ADD_BRANCH_SUBROUTINE  ;ADD & ADDA

*---CHECK FOR AND-----
    CMP.B   #$0,D6
    BEQ     PROCESS_AND             ;AND

*CHECK FOR LSd, ASd, & ROd
    CMP.B   #$2,D6
    BEQ     startLS ;MARTIN'S WORKING ON THIS

    JMP     PRINT_DATA


*++++++++++++++++++++++++++++++++++NOP & RTS+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR NOP
*D7 = ORIGINAL WORD OF MEMORY
PRINT_NOP
*----I/O NOP----
    LEA     MESSAGE_NOP,A1
    MOVE.B  #14,D0
    TRAP    #15

    JMP     PRIMELOOP

*--------------------------------------------
*PROCESS OUTPUT FOR NOP
*D7 = ORIGINAL WORD OF MEMORY
PRINT_RTS
*----I/O RTS----
    LEA     MESSAGE_RTS,A1
    MOVE.B  #14,D0
    TRAP    #15

    JMP     PRIMELOOP

*++++++++++++++++++++++++++++++++++MOVE, MOVEA, MOVEQ, MOVEM+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR MOVEA
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_MOVEA
*----I/O MOVEA----
    LEA     MESSAGE_MOVEA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----COMPARE SIZE----
    MOVE.W  D7,D6
    AND.W   #$3000,D6
    ROL.W   #4,D6

    CMP.B   #3,D6
    BEQ     PRINT_MOVEA_WORD

    CMP.B   #2,D6
    BEQ     PRINT_MOVEA_LONG

*--------------------------------------------
*PROCESS OUTPUT FOR MOVEA WORD
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVEA_WORD
*----I/O----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_MOVEA_EA

*--------------------------------------------
*PROCESS OUTPUT FOR MOVEA LONG
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVEA_LONG
*----I/O----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_MOVEA_EA

*--------------------------------------------
*PROCESS OUTPUT FOR MOVEA EA
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVEA_EA
*----PRINT SOURCE EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6
    JSR     DeAddr              ;PRINT EA


*----COMMA----
    LEA     MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----PRINT DESTINATION EA----
    LEA     MESSAGE_ADDRESS,A1
    MOVE.B  #14,D0
    TRAP    #15

    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6
    MOVE.L  D6,D1
    MOVE.B  #15,D0
    MOVE.B  #10,D2
    TRAP    #15


*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PROCESS OUTPUT FOR MOVE
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_MOVE
*----I/O MOVE----
    LEA     MESSAGE_MOVE,A1
    MOVE.B  #14,D0
    TRAP    #15

*----COMPARE SIZE----
    MOVE.W  D7,D6
    AND.W   #$3000,D6
    ROL.W   #4,D6

    CMP.B   #1,D6
    BEQ     PRINT_MOVE_BYTE

    CMP.B   #3,D6
    BEQ     PRINT_MOVE_WORD

    CMP.B   #2,D6
    BEQ     PRINT_MOVE_LONG

    JMP     PRINT_DATA

*--------------------------------------------
*PROCESS OUTPUT FOR MOVEQ
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_MOVEQ
    *JMP     CHECK_AND_OR_MOVEQ_EA       ;CHECK IF EA IS VALID
*----I/O MOVEQ----
    LEA     MESSAGE_MOVEQ,A1
    MOVE.B  #14,D0
    TRAP    #15

*----I/O LONG----   ;ONLY CAN BE LONG
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

*----I/O HEX---
    LEA     MESSAGE_HEX,A1
    MOVE.B  #14,D0
    TRAP    #15

*----I/O DATA(HEX FORMAT)----
    MOVE.W  D7,D6
    AND.W   #$00FF,D6
    MOVE.L  D6,D1
    MOVE.B  #15,D0
    MOVE.B  #16,D2      ;PRINT AS HEX
    TRAP    #15

*----COMMA----
    LEA     MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----I/O REGISTER----
    LEA     MESSAGE_DIRECTORY,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY NUMBER I/O----
    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #7,D6
    MOVE.L  D6,D1
    MOVE.B  #10,D2
    MOVE.B  #15,D0
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP


*--------------------------------------------
*PROCESS OUTPUT FOR MOVE & MOVEA BYTE
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVE_BYTE
*----I/O----
    LEA     MESSAGE_BYTE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_MOVE_EA

*--------------------------------------------
*PROCESS OUTPUT FOR MOVE WORD
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVE_WORD
*----I/O----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_MOVE_EA

*--------------------------------------------
*PROCESS OUTPUT FOR MOVE LONG
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVE_LONG
*----I/O----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_MOVE_EA

*--------------------------------------------
*PROCESS OUTPUT FOR MOVE EA
*D7 = ORIGINAL WORD OF MEMORY
PRINT_MOVE_EA
*----PRINT SOURCE EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6
    JSR     DeAddr              ;PRINT EA


*----COMMA----
    LEA     MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----PRINT DESTINATION EA----
    MOVE.W  D7,D6
    MOVE.W  D7,D5
    AND.W   #$0E00,D6
    LSR.W   #8,D6
    LSR.W   #1,D6
    AND.W   #$01C0,D5
    LSR.W   #3,D5
    Add    D5,D6
    JSR     DeAddr              ;PRINT EA


*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP


*++++++++++++++++++++++++++++++++++LEA+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR LEA
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_LEA
    JSR     CHECK_LEA_JSR_EA

PROCESS_LEA_CORRECT

*----I/O LEA----
    LEA     MESSAGE_LEA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----SETUP EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6
    JSR     DeAddr              ;PRINT EA

*----COMMA----
    LEA     MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----An----
    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6

    LEA     MESSAGE_ADDRESS,A1
    MOVE.B  #14,D0
    TRAP    #15

    MOVE.L  D6,D1
    MOVE.B  #3,D0
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*CHECK IF LEA & JSR ea IS VALID
*D7 = ORIGINAL WORD OF MEMORY
CHECK_LEA_JSR_EA
*----CHECK INVALID EA----
    MOVE.W  D7,D6
    AND.W   #$0038,D6
    LSR.B   #$3,D6

    CMP.B   #$2,D6          ;IF Dn OR An
    BLT     PRINT_DATA

    CMP.B   #$3,D6          ;IF (An)+
    BEQ     PRINT_DATA

    CMP.B   #$4,D6          ;IF -(An)
    BEQ     PRINT_DATA

    CMP.B   #$7,D6          ;IF EA MODE == #7
    BEQ     CHECK_LEA_EA
*--------------------------------------------
*CHECK IF LEA ea IS VALID WHEN MODE == %111
*D7 = ORIGINAL WORD OF MEMORY
CHECK_LEA_EA
    MOVE.W  D7,D6
    AND.W   #$0007,D6

    CMP.B   #$4,D6
    BEQ     PRINT_DATA

    JMP     PROCESS_LEA_CORRECT
*++++++++++++++++++++++++++++++++++JSR+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR JSR
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_JSR
    JMP     CHECK_JSR_EA        ;CHECK THAT EA IS VALID
PROCESS_JSR_CORRECT
*----I/O JSR----
    LEA     MESSAGE_JSR,A1
    MOVE.B  #14,D0
    TRAP    #15

*----SETUP EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6
    JSR     DeAddr              ;PRINT EA


*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*CHECK IF LEA & JSR ea IS VALID
*D7 = ORIGINAL WORD OF MEMORY
CHECK_JSR_EA
*----CHECK INVALID EA----
    MOVE.W  D7,D6
    AND.W   #$0038,D6
    LSR.B   #$3,D6

    CMP.B   #$2,D6          ;IF Dn OR An
    BLT     PRINT_DATA

    CMP.B   #$3,D6          ;IF (An)+
    BEQ     PRINT_DATA

    CMP.B   #$4,D6          ;IF -(An)
    BEQ     PRINT_DATA

    CMP.B   #$7,D6          ;IF EA MODE == #7
    BEQ     CHECK_JSR_EA_TWO
*--------------------------------------------
*CHECK IF LEA ea IS VALID WHEN MODE == %111
*D7 = ORIGINAL WORD OF MEMORY
CHECK_JSR_EA_TWO
    MOVE.W  D7,D6
    AND.W   #$0007,D6

    CMP.B   #$4,D6
    BEQ     PRINT_DATA

    JMP     PROCESS_JSR_CORRECT
*++++++++++++++++++++++++++++++++++NOT+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR NOT
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_NOT
*----CHECK THAT ea IS VALID ----
    MOVE.W  D7,D6
    AND.W   #$0038,D6
    LSR.B   #$3,D6

    CMP.B   #$1,D6
    BEQ     PRINT_DATA

    CMP.B   #$7,D6
    BEQ     CHECK_NOT_EA

*----I/O NOT----
    LEA     MESSAGE_NOT,A1
    MOVE.B  #14,D0
    TRAP    #15

*----SETUP FOR COMPARE----
    MOVE.W  D7,D6
    AND.W   #$00C0,D6
    LSR.B   #6,D6

*----CHECK FOR BYTE----
    CMP.B   #$0,D6
    BEQ     PRINT_NOT_BYTE

*----CHECK FOR WORD----
    CMP.B   #$1,D6
    BEQ     PRINT_NOT_WORD

*----CHECK FOR LONG----
    CMP.B   #$2,D6
    BEQ     PRINT_NOT_LONG

*--------------------------------------------
*CHECK REGISTER IS VALID WHEN EA MODE == %111
*D7 = ORIGINAL WORD OF MEMORY
CHECK_NOT_EA
    MOVE.W  D7,D6
    AND.W   #$0007,D6

    CMP.B   #$1,D6
    BEQ     PRINT_DATA

    CMP.B   #$2,D6
    BGE     CHECK_ADD_ERROR_EA_REGISTER

    RTS

*--------------------------------------------
*PROCESS OUTPUT FOR NOT BYTE & EA
*D7 = ORIGINAL WORD OF MEMORY
PRINT_NOT_BYTE
*----I/O BYTE----
    LEA     MESSAGE_BYTE,A1
    MOVE.B  #14,D0
    TRAP    #15

*----SETUP EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JMP     DeAddr              ;PRINT EA


*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PROCESS OUTPUT FOR NOT WORD & EA
*D7 = ORIGINAL WORD OF MEMORY
PRINT_NOT_WORD
*----I/O WORD----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

*----SETUP EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JMP     DeAddr              ;PRINT EA



*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PROCESS OUTPUT FOR NOT LONG & EA
*D7 = ORIGINAL WORD OF MEMORY
PRINT_NOT_LONG
*----I/O BYTE----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

*----SETUP EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JMP     DeAddr              ;PRINT EA



    *----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*++++++++++++++++++++++++++++++++++AND+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR AND
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_AND
    JSR     CHECK_AND_OR_MOVEQ_EA     ;FUNCTION CHECKS IF EA IS VALID

*----I/O AND----
    LEA     MESSAGE_AND,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_OPMODE

*--------------------------------------------
*CHECK AND, OR, & MOVEQ ea TO ENSURE IT IS VALID
*D7 = ORIGINAL WORD OF MEMORY
CHECK_AND_OR_MOVEQ_EA
*----CHECK ea VALID----
    MOVE.W  D7,D6
    AND.W   #$0038,D6
    LSR.W   #$3,D6

    CMP.B   #$1,D6          ;IF EA MODE == An
    BEQ     PRINT_DATA
    RTS

*++++++++++++++++++++++++++++++++++OR+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR OR
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_OR
    JMP     CHECK_AND_OR_MOVEQ_EA     ;FUNCITON CHECKS IF EA IS VALID
*----I/O OR----
    LEA     MESSAGE_OR,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_OPMODE

*++++++++++++++++++++++++++++++++++SUB+++++++++++++++++++
*--------------------------------------------
*PROCESS OUTPUT FOR SUB
*D7 = ORIGINAL WORD OF MEMORY
PROCESS_SUB
*----I/O SUB----
    LEA     MESSAGE_SUB,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_OPMODE

*++++++++++++++++++++++++++++++++++ADD,ADDA,ADDQ+++++++++++++++++++
*--------------------------------------------
*BRANCH SUBROUTINE
*CHECKING ADD VS ADDA
*D7 = ORIGINAL WORD OF MEMORY
ADD_BRANCH_SUBROUTINE
*---SETUP----------
    MOVE.W  D7,D6
    AND.W   #$01C0,D6
    LSR.W   #6,D6

*----CHECK FOR ADDA---
    CMP.B   #$3,D6
    BEQ     PROCESS_ADDA    ;ADDA

    CMP.B   #$7,D6
    BEQ     PROCESS_ADDA

*----ALL OTHER ADD---
    BRA     PROCESS_ADD     ;ADD

*--------------------------------------------
*PROCESS PRINT FOR ADDA
*D7=ORIGINAL
PROCESS_ADDA
*----I/O ADDA----
    LEA     MESSAGE_ADDA,A1
    MOVE.B  #14,D0
    TRAP #15

*----SETUP FOR SIZE COMPARE----
    MOVE.W  D7,D6
    AND.W   #$01C0,D6
    LSR.W   #$6,D6

*----COMPARE FOR OPMODE----
    CMP.B   #$3,D6
    BEQ     PROCESS_ADDA_WORD

    CMP.B   #$7,D6
    BEQ     PROCESS_ADDA_LONG

*--------------------------------------------
*PROCESS ADDA FORMAT 'ADDA.W <EA>,An
*D7=ORIGINAL
PROCESS_ADDA_WORD
*----SIZE OUTPUT----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

*----EA OUTPUT----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JSR     DeAddr              ;PRINT EA

*----PRINT COMMA----
    LEA MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY OUTPUT----

    LEA     MESSAGE_ADDRESS,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY NUMBER----
    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6
    MOVE.B  #3,D0
    MOVE.W  D6,D1
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PROCESS ADDA FORMAT 'ADDA.L <EA>,An
*D7=ORIGINAL
PROCESS_ADDA_LONG
*----SIZE OUTPUT----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

*----EA OUTPUT----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JSR     DeAddr              ;PRINT EA

*----PRINT COMMA----
    LEA MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY OUTPUT----

    LEA     MESSAGE_DIRECTORY,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY NUMBER----
    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6
    MOVE.B  #3,D0
    MOVE.W  D6,D1
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PROCESS PRINT FOR ADD
*D7=ORIGINAL
PROCESS_ADD
    JMP     CHECK_ADD_ERROR

PROCESS_ADD_CLEAR
*----I/O ADD----
    LEA     MESSAGE_ADD,A1
    MOVE.B  #14,D0
    TRAP    #15



    BRA     PRINT_OPMODE

*--------------------------------------------
*CHECK IF EA IS CORRECT FOR ADD
*D7=ORIGINAL
CHECK_ADD_ERROR
    MOVE.W  D7,D6
    AND.W   #$01C0,D6
    LSR.W   #6,D6

*----CHECK IF OPMODE = 4, 5, OR 6----
    CMP.B   #$4,D6
    BGE     CHECK_ADD_EA

    JMP     PROCESS_ADD_CLEAR           ;RETURN TO PROCESS_ADD

*--------------------------------------------
*IF OPMODE SHOWS ADD, LSs Dn,<ea>, CHECK DESTINATION IS VALID
*D7=ORIGINAL
CHECK_ADD_EA
    MOVE.W  D7,D6
    AND.W   #$0038,D6
    LSR.W   #$3,D6

*----CHECK FOR Dn & An----
    CMP.B   #$1,D6
    BLE     PRINT_DATA

*----CHECK FOR MODE 111----
    CMP.B   #$7,D6
    BEQ     CHECK_ADD_ERROR_EA_REGISTER

    RTS

*--------------------------------------------
*CHECK IF ea OPMODE OF 111 IS VALID
*D7=ORIGINAL
CHECK_ADD_ERROR_EA_REGISTER
    MOVE.W  D7,D6
    AND.W   #$0007,D6

    CMP.B   #$1,D6
    BGT     PRINT_DATA

    RTS
*--------------------------------------------
*PROCESS PRINT FOR ADDQ
*D7=ORIGINAL
PROCESS_ADDQ
*----CHECK FOR OPMODE ERROR----
    MOVE.W  D7,D6
    AND.W   #$0038,D6
    LSR.B   #$3,D6

    CMP.B   #$7,D6
    BEQ     CHECK_ADD_ERROR_EA_REGISTER

*----I/O ADDQ----
    LEA     MESSAGE_ADDQ,A1
    MOVE.B  #14,D0
    TRAP    #15


*----COMPARE FOR SIZE----
    MOVE.W  D7,D6
    AND.W   #$00C0,D6
    LSR.W   #6,D6

    CMP.B   #$0,D6
    BEQ     PRINT_ADDQ_BYTE

    CMP.B   #$1,D6
    BEQ     PRINT_ADDQ_WORD

    CMP.B   #$2,D6
    BEQ     PRINT_ADDQ_LONG

*--------------------------------------------
*PROCESS PRINT FOR ADDQ
*D7=ORIGINAL
PRINT_ADDQ_BYTE
*----I/O BYTE----
    LEA     MESSAGE_BYTE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_ADDQ_DATA

*--------------------------------------------
*PROCESS PRINT FOR ADDQ
*D7=ORIGINAL
PRINT_ADDQ_WORD
*----I/O BYTE----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_ADDQ_DATA

*--------------------------------------------
*PROCESS PRINT FOR ADDQ
*D7=ORIGINAL
PRINT_ADDQ_LONG
*----I/O BYTE----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_ADDQ_DATA

*--------------------------------------------
*PROCESS DATA PRINT FOR ADDQ
*D7=ORIGINAL
PRINT_ADDQ_DATA
*----I/O DATA----
    LEA     MESSAGE_HEX,A1
    MOVE.B  #14,D0
    TRAP    #15


*----register----

    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6
    MOVE.B  D6,D1
    MOVE.B  #15,D0
    MOVE.B  #16,D2
    TRAP    #15

*----COMMA----
    LEA     MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----EA----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JSR     DeAddr              ;PRINT EA


*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*++++++++++++++++++++++++++++++++++OUTPUT REGISTER, OPMODE, & EA+++++++++++++++++++
*OUTPUT PRINT FOR ADD, ADDA, SUB, AND, OR
*=D7 = ORIGINAL WORD
PRINT_OPMODE
*----SETUP FOR SIZE COMPARE----
    MOVE.W  D7,D6
    AND.W   #$01C0,D6
    LSR.W   #$6,D6

*----COMPARE FOR OPMODE----
    CMP.B   #$0,D6
    BEQ     PROCESS_OPMODE_BYTEa

    CMP.B   #$1,D6
    BEQ     PROCESS_OPMODE_WORDa

    CMP.B   #$2,D6
    BEQ     PROCESS_OPMODE_LONGa

    CMP.B   #$4,D6
    BEQ     PROCESS_OPMODE_BYTEb

    CMP.B   #$5,D6
    BEQ     PROCESS_OPMODE_WORDb

    CMP.B   #$6,D6
    BEQ     PROCESS_OPMODE_LONGb
*--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.B <EA>,Dn
*D7=ORIGINAL
PROCESS_OPMODE_BYTEa
*----SIZE OUTPUT----
    LEA     MESSAGE_BYTE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_EA_Dn



*--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.W <EA>,Dn
*D7=ORIGINAL
PROCESS_OPMODE_WORDa
*----SIZE OUTPUT----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_EA_Dn

*--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.L <EA>,Dn
*D7=ORIGINAL
PROCESS_OPMODE_LONGa
*----SIZE OUTPUT----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_EA_Dn

*--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.B <EA>,Dn
*D7=ORIGINAL
PRINT_EA_Dn
*----EA OUTPUT----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JSR     DeAddr              ;PRINT EA

*----PRINT COMMA----
    LEA MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY OUTPUT----

    LEA     MESSAGE_DIRECTORY,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY NUMBER----
    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6
    MOVE.B  #3,D0
    MOVE.W  D6,D1
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.B Dn,<EA>
*D7=ORIGINAL
PROCESS_OPMODE_BYTEb
*----SIZE OUTPUT----
    LEA     MESSAGE_BYTE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_Dn_EA

*--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.W Dn,<EA>
*D7=ORIGINAL
PROCESS_OPMODE_WORDb
*----SIZE OUTPUT----
    LEA     MESSAGE_WORD,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA PRINT_Dn_EA

 *--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.L Dn,<EA>
*D7=ORIGINAL
PROCESS_OPMODE_LONGb
*----SIZE OUTPUT----
    LEA     MESSAGE_LONG,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRINT_Dn_EA

 *--------------------------------------------
*PROCESS & OUTPUT FOR ADD, AND, OR, SUB FORMAT 'ADD.L Dn,<EA>
*D7=ORIGINAL
PRINT_Dn_EA
*----DIRECTORY OUTPUT----

    LEA     MESSAGE_DIRECTORY,A1
    MOVE.B  #14,D0
    TRAP    #15

*----DIRECTORY NUMBER----
    MOVE.W  D7,D6
    AND.W   #$0E00,D6
    ROL.W   #$7,D6
    MOVE.B  #3,D0
    MOVE.B  D6,D1
    TRAP    #15

*----PRINT COMMA----
    LEA MESSAGE_COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----EA OUTPUT----
    MOVE.W  D7,D6
    AND.W   #$003F,D6

    JSR     DeAddr              ;PRINT EA


*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*++++++++++++++++++++++++++++++++++Bcc+++++++++++++++++++
*--------------------------------------------
*PROCESS BCC'S SUBROUTINE FOR CONDITION
*D7=ORIGINAL
PROCESS_BCC
*-----CONDITION----
    MOVE.W  D7,D6       ;SETUP
    AND.W   #$0F00,D6   ;CLEAR ALL BUT BITS 11-8
    LSR.W   #8,D6       ;MOVE BITS 11-8 TO 3-0

*----CHECK RA----
    CMP.B   #$0,D6
    BEQ     PRINT_BRA
*----CHECK HI----
    CMP.B   #$2,D6
    BEQ     PRINT_BHI

*----CHECK LS----
    CMP.B   #$3,D6
    BEQ     PRINT_BLS
*----CHECK CC----
    CMP.B   #$4,D6
    BEQ     PRINT_BCC

*----CHECK CS----
    CMP.B   #$5,D6
    BEQ     PRINT_BCS

*----CHECK NE----
    CMP.B   #$6,D6
    BEQ     PRINT_BNE

*----CHECK EQ----
    CMP.B   #$7,D6
    BEQ     PRINT_BEQ

*----CHECK VC----
    CMP.B   #$8,D6
    BEQ     PRINT_BVC

*----CHECK VS----
    CMP.B   #$9,D6
    BEQ     PRINT_BVS

*----CHECK PL----
    CMP.B   #$A,D6
    BEQ     PRINT_BPL

*----CHECK MI----
    CMP.B   #$B,D6
    BEQ     PRINT_BMI

*----CHECK GE----
    CMP.B   #$C,D6
    BEQ     PRINT_BGE

*----CHECK LT----
    CMP.B   #$D,D6
    BEQ     PRINT_BLT

*----CHECK GT----
    CMP.B   #$E,D6
    BEQ     PRINT_BGT

*----CHECK LE----
    CMP.B   #$F,D6
    BEQ     PRINT_BLE


*--------------------------------------------
*PRINT BRA THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BRA
    LEA     MESSAGE_BRA,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BHI THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BHI
    LEA     MESSAGE_BHI,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BLS THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BLS
    LEA     MESSAGE_BLS,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC


*--------------------------------------------
*PRINT BCC THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BCC
   LEA     MESSAGE_BCC,A1
   MOVE.B  #14,D0
   TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BCS THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BCS
    LEA     MESSAGE_BCS,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BNE THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BNE
    LEA     MESSAGE_BNE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BEQ THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BEQ
    LEA     MESSAGE_BEQ,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BVC THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BVC
    LEA     MESSAGE_BVC,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BVS THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BVS
    LEA     MESSAGE_BVS,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BPL THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BPL
    LEA     MESSAGE_BPL,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BMI THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BMI
    LEA     MESSAGE_BMI,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BGE THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BGE
    LEA     MESSAGE_BGE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BLT THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BLT
    LEA     MESSAGE_BLT,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BGT THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BGT
    LEA     MESSAGE_BGT,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PRINT BLE THEN MOVE TO DISPLACEMENT_BCC
*D7=ORIGINAL
PRINT_BLE
    LEA     MESSAGE_BLE,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA DISPLACEMENT_BCC

*--------------------------------------------
*PROCESS SIZE OF DISPLACEMENT THEN MOVE TO PRINT FUNCTIONS
*D7=ORIGINAL
DISPLACEMENT_BCC
*----SETUP----
    MOVE.W  D7,D6
    AND.W   #$00FF,D6

*----CHECK FOR 16----
    CMP.B   #$00,D6
    BEQ     PRINT_16BIT

*----CHECK FOR 32----
    CMP.B   #$FF,D6
    BEQ     PRINT_32BIT

*----ALL OTHERS----
    BRA     PRINT_8BIT

*--------------------------------------------
*PRINT 16 BIT DISPLACEMENT
*D7=ORIGINAL
PRINT_16BIT
    MOVE.W  (A5)+,D1
    MOVE.B  #15,D0
    MOVE.B  #16,D2
    TRAP    #15
*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PRINT 32 BIT DISPLACEMENT
*D7=ORIGINAL
PRINT_32BIT
    MOVE.L  (A5)+,D1
    MOVE.B  #15,D0
    MOVE.B  #16,D2
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PRINT 8 BIT DISPLACEMENT
*D7=ORIGINAL
PRINT_8BIT
    MOVE.B  D7,D1
    MOVE.B  #15,D0
    MOVE.B  #16,D2
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    BRA     PRIMELOOP

*--------------------------------------------
*PRINT WORD OF DATA THAT DOES NOT MATCH DECODING OPTIONS
*D7=ORIGINAL
PRINT_DATA
*----I/O DATA----
    LEA     MESSAGE_DATA,A1
    MOVE.B  #14,D0
    TRAP    #15

*----PRINT DATA AS HEX----
    MOVE.B  #15,D0
    MOVE.W  D7,D1
    MOVE.B  #16,D2
    TRAP    #15

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    JMP     PRIMELOOP


ENDPROGRAM LEA     MESSAGE_quit,A1
    MOVE.B  #14,D0
    TRAP    #15

    MOVE.B  #5,D0
    TRAP    #15
    
    MOVE.B  #9,D0
    TRAP    #15

    SIMHALT



*----------------------Martin Code--------------------------------
*----------------------MOVEM--------------------------------

*Start of the move M function
MOVEMfunc    JSR printMOVEM
*print size
    MOVE D7,D6
    AND #64,D6
    LSR #6,D6
    CMP #0,D6
    BEQ PRINTSIZEDW
    BRA PRINTSIZEDL

MOVEFUNCTWO
    JSR printTAP
* define read or write
    MOVE D7,D6
    AND #1024,D6
    LSR #6,D6
    CMP #0,D6
    BEQ MOVEMwrite
    BRA MOVEMread
*Register to memory ( mesh ,EA)
MOVEMwrite  MOVE.W (A5)+,D6
    MOVE #0,D1
    MOVE #0,D2
    JSR FirstD
    JSR printcomma
    JSR DeAddr
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA ENDMOVEMfunc
*memory to Register ( EA, mesh )
MOVEMread      JSR DeAddr
    JSR printcomma
    MOVE.W (A5)+,D6
    MOVE #0,D1
    MOVE #0,D2
    JSR FirstD
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

ENDMOVEMfunc
    JMP     PRIMELOOP

printMOVEM  LEA     MESSAGE_MOVEM,A1
        MOVE.B  #14,D0
        TRAP    #15
        RTS

printTAP  LEA    TAP,A1
        MOVE.B  #14,D0
        TRAP    #15
        RTS

printcomma  LEA     comma,A1
        MOVE.B  #14,D0
        TRAP    #15
        RTS

PRINTSIZEDW  LEA     dotw,A1
        MOVE.B  #14,D0
        TRAP    #15
        JMP     MOVEFUNCTWO

PRINTSIZEDL  LEA     dotl,A1
        MOVE.B  #14,D0
        TRAP    #15
        JMP     MOVEFUNCTWO
*=============================================================
* print the mesh of moveM
FirstD
    CMP #8,D1
    BEQ FirstAST
    MOVE D6,D5

* DETERMINE DIRECTION(READ OR WRITE TO M)
    CMP #0,D4
    BEQ FDIN
    BRA FDRE
FDIN    AND #1,D5
    LSR #1,D6
    BRA ENDFDIN
FDRE    AND #32768,D5
    LSL #1,D6

ENDFDIN    CMP #0,D5
    BEQ FirstDADDONE
    JSR PRINTDMM
    JSR PRINTDIGIMM
    BRA NextDST
FirstDADDONE    ADD #1,D1
    BRA FirstD

* PRINT NEXT D# START WITH /
NextDST ADD #1,D1
NextD   CMP #8,D1
    BEQ FirstASTSL
    MOVE D6,D5
* DETERMINE DIRECTION(READ OR WRITE TO M)
    CMP #0,D4
    BEQ NDIN
    BRA NDRE
NDIN    AND #1,D5
    LSR #1,D6
    BRA ENDNDIN
NDRE    AND #32768,D5
    LSL #1,D6

ENDNDIN CMP #0,D5
    BEQ NEXTDADDONE
    JSR PRINTSLASHMM
    JSR PRINTDMM
    JSR PRINTDIGIMM
NEXTDADDONE    ADD #1,D1
    BRA NEXTD

*======================================================================

*SET PRINT SLASH FLAG TO 1 AS THERE IS D#
FirstASTSL MOVE #1,D2
* PRINT FIRST A#
FirstAST MOVE #0,D1

FirstA  CMP #8,D1
    BEQ MESHEND
    MOVE D6,D5

* DETERMINE DIRECTION(READ OR WRITE TO M)
    CMP #0,D4
    BEQ FAIN
    BRA FARE
FAIN    AND #1,D5
    LSR #1,D6
    BRA ENDFAIN
FARE    AND #32768,D5
    LSL #1,D6

ENDFAIN   CMP #0,D5
    BEQ FirstAADDONE

    CMP #0,D2
    BEQ noslash
    JSR PRINTSLASHMM
noslash    JSR PRINTAMM
    JSR PRINTDIGIMM
    BRA NextAST
FirstAADDONE    ADD #1,D1
    BRA FirstA

NextAST ADD #1,D1
NextA   CMP #8,D1
    BEQ MESHEND
    MOVE D6,D5
* DETERMINE DIRECTION(READ OR WRITE TO M)
    CMP #0,D4
    BEQ NAIN
    BRA NARE
NAIN    AND #1,D5
    LSR #1,D6
    BRA ENDNAIN
NARE    AND #32768,D5
    LSL #1,D6

ENDNAIN    CMP #0,D5
    BEQ NEXTAADDONE
    JSR PRINTSLASHMM
    JSR PRINTAMM
    JSR PRINTDIGIMM
NEXTAADDONE    ADD #1,D1
    BRA NEXTA

MESHEND RTS

*PRINT D FOR MOVEM
PRINTDMM    LEA     D,A1
        MOVE.B  #14,D0
        TRAP    #15
        RTS

*PRINT A FOR MOVEM
PRINTAMM    LEA     A,A1
        MOVE.B  #14,D0
        TRAP    #15
        RTS
*PRINT DIGI MOVE M
PRINTDIGIMM   MOVE.B  #3,D0
    TRAP    #15
    RTS

*PRINT /
PRINTSLASHMM    LEA     SLASH,A1
        MOVE.B  #14,D0
        TRAP    #15
        RTS

*----------------------LSd,ASd,ROd--------------------------------
startLS    MOVE D7,D6
    AND #192,D6
    LSR #6,D6
    CMP #3,D6
    BEQ MSLS
    BRA NormalLS
*memory shift section
MSLS    * LS, AS, RO
    LSR #8,D6
    LSR #1,D6
    AND #3,D6
    CMP #1,D6
    BEQ PRINTLSM
    CMP #0,D6
    BEQ PRINTASM
    CMP #3,D6
    BEQ PRINTROM

MSLR    MOVE D7,D6
    AND #256,D6
    CMP #0,D6
    BEQ PRINTRM
    BRA PRINTLM
MSEA    MOVE D7,D6
*print effective address.... need to copy
    BRA ENDOFLR


PRINTLSM LEA     LS,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA MSLR
PRINTASM LEA     AS,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA MSLR
PRINTROM LEA     RO,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA MSLR
PRINTLM LEA     L,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DefineSIZE
PRINTRM LEA     R,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DefineSIZE



NormalLS    MOVE D7,D6
* LS, AS, RO
    AND #24,D6
    LSR #3,D6
    CMP #1,D6
    BEQ PRINTLS
    CMP #0,D6
    BEQ PRINTAS
    CMP #3,D6
    BEQ PRINTRO

* left or right
LRDefine MOVE D7,D6
    AND #256,D6
    CMP #0,D6
    BEQ PRINTR
    BRA PRINTL

* size
DefineSIZE    MOVE D7,D6
    AND #192,D6
    LSR #6,D6
    CMP #0,D6
    BEQ PRINTSIZEB
    CMP #1,D6
    BEQ PRINTSIZEW
    BRA PRINTSIZEL

*D# OR # IE: LSL.R (d# / #)
DEFINENUM MOVE D7,D6
    AND #16,D6
    CMP #0,D6
    BEQ PRINTNUM
    MOVE D7,D6
    AND #1792,D6
    LSR #8,D6
    MOVE D6,D1
    JSR PRINTDADDR

*DISTINATION D#
DEFINEDIS MOVE D7,D6
    LEA     COMMA,A1
    MOVE.B  #14,D0
    TRAP    #15
    AND #7,D6
    MOVE    D6,D1
    JSR PRINTDADDR
    BRA ENDOFLR

PRINTLS LEA     LS,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA LRDefine
PRINTAS LEA     AS,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA LRDefine
PRINTRO LEA     RO,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA LRDefine
PRINTL LEA     L,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DefineSIZE
PRINTR LEA     R,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DefineSIZE
PRINTSIZEB LEA     SizeB,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DEFINENUM
PRINTSIZEW LEA     SizeW,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DEFINENUM
PRINTSIZEL  LEA     SizeL,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA DEFINENUM
PRINTDADDR LEA D,A1
    MOVE.B  #14,D0
    TRAP    #15
    MOVE.B  #3,D0
    TRAP    #15
    RTS
PRINTNUM LEA NUM,A1
    MOVE.B  #14,D0
    TRAP    #15
    MOVE D7,D6
    LSR #8,D6
    LSR #1,D6
    AND #7,D6
    MOVE    D6,D1
    MOVE.B  #3,D0
    TRAP    #15
    BRA     DEFINEDIS

ENDOFLR MOVE D6,D5

*----NEW LINE----
    LEA     new_line,A1
    MOVE.B  #14,D0
    TRAP    #15

    JMP     PRIMELOOP
*----------------------EA--------------------------------
* Assuming address is in D1

DeAddr  MOVE.L D6,D3
        AND #63,D3
* decode MODE
        MOVE    D3,D4
        ASR #3,D4
        CMP #0,D4
        BEQ REGISTERD
        CMP #1,D4
        BEQ REGISTERA
        CMP #2,D4
        BEQ DIRADDR
        CMP #3,D4
        BEQ DIRADDRP
        CMP #4,D4
        BEQ DIRADDRN
        CMP #7,D4
        BEQ TEMPADDR
        BRA EndDeAddr ;JUST INCASE

*SECTION FOR D# AND A#
REGISTERD    LEA     D,A1
        MOVE.B  #14,D0
        TRAP    #15
        JSR PRINTDIGI
        BRA EndDeAddr
REGISTERA  LEA     A,A1
        MOVE.B  #14,D0
        TRAP    #15
        JSR PRINTDIGI
        BRA EndDeAddr


*PRINT REGISTER#
PRINTDIGI   AND #7,D3
    MOVE.W  D3,D1
    MOVE.B  #3,D0
    TRAP    #15
    RTS


*DIRECT ADDRESS (A#)
DIRADDR LEA     ABra,A1
        MOVE.B  #14,D0
        TRAP    #15
    JSR PRINTDIGI
    LEA     CloBra,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA EndDeAddr

*DIRECT ADDRESS (A#)+
DIRADDRP LEA     ABra,A1
        MOVE.B  #14,D0
        TRAP    #15
    JSR PRINTDIGI
    LEA     CloBra,A1
    MOVE.B  #14,D0
    TRAP    #15
    LEA     PlusSign,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA EndDeAddr

*DIRECT ADDRESS -(A#)
DIRADDRN LEA     NegSign,A1
        MOVE.B  #14,D0
        TRAP    #15
    LEA     ABra,A1
    MOVE.B  #14,D0
    TRAP    #15
    JSR PRINTDIGI
    LEA     CloBra,A1
    MOVE.B  #14,D0
    TRAP    #15
    BRA EndDeAddr


*TEMPADDR # OR L OR W
TEMPADDR    AND #7,D3
    CMP #0,D3
    BRA WORDADDR
    CMP #1,D3
    BRA LONGADDR
    CMP #4,D3
    BRA IMMEADDR
    BRA EndDeAddr

WORDADDR MOVE.W (A5)+,D1
    MOVE.B  #3,D0
    TRAP    #15
    BRA EndDeAddr

LONGADDR    MOVE.L (A5)+,D1
    MOVE.B  #3,D0
    TRAP    #15
    BRA EndDeAddr

IMMEADDR    LEA     NumSign,A1
        MOVE.B  #14,D0
        TRAP    #15
    MOVE.W (A5)+,D1
    MOVE.B  #3,D0
    TRAP    #15
    BRA EndDeAddr




EndDeAddr   RTS
*----------------------Dale Variables--------------------------------
io_start     ds.l      40
io_end       ds.l      40
start_address_msg     dc.b      'Please enter an 8 byte hexadecimal address: ',0
end_address_msg       dc.b      'Please enter an 8 byte hexadecimal address: ',0
starting_prompt       dc.b      'Welcome to the program',CR,LF,0
min_size        dc.b      $30
max_number_value dc.b     $39
smallest_letter dc.b      $40
max_letter_size_uppercase dc.b      $47
invalid_sixty_six dc.b    $66
invalid_sixty dc.b        $60
init_counter     dc.b     $4
new_line         dc.b      '',CR,LF,0
not_valid       dc.b      'This entry is not valid',CR,LF,0
init_addr       dc.w      $6000

CR              EQU     $0D
LF              EQU     $0A

*----------------------Daniel Variables--------------------------------
SP                  EQU    $00000999

MESSAGE_ADD         DC.B    'ADD',0
MESSAGE_ADDA        DC.B    'ADDA',0
MESSAGE_AND         DC.B    'AND',0
MESSAGE_OR          DC.B    'OR',0
MESSAGE_SUB         DC.B    'SUB',0
MESSAGE_NOT         DC.B    'NOT',0
MESSAGE_JSR         DC.B    'JSR    ',0
MESSAGE_LEA         DC.B    'LEA    ',0
MESSAGE_ADDQ        DC.B    'ADDQ',0
MESSAGE_MOVE        DC.B    'MOVE',0
MESSAGE_MOVEQ       DC.B    'MOVEQ',0
MESSAGE_MOVEA       DC.B    'MOVEA',0
MESSAGE_NOP         DC.B    'NOP',CR,LF,0
MESSAGE_RTS         DC.B    'RTS',CR,LF,0

MESSAGE_BRA       DC.B    'BRA     ',0
MESSAGE_BHI       DC.B    'BHI     ',0
MESSAGE_BLS       DC.B    'BLS     ',0
MESSAGE_BCC       DC.B    'BCC     ',0
MESSAGE_BCS       DC.B    'BCS     ',0
MESSAGE_BNE       DC.B    'BNE     ',0
MESSAGE_BEQ       DC.B    'BEQ     ',0
MESSAGE_BVC       DC.B    'BVC     ',0
MESSAGE_BVS       DC.B    'BVS     ',0
MESSAGE_BPL       DC.B    'BPL     ',0
MESSAGE_BMI       DC.B    'BMI     ',0
MESSAGE_BGE       DC.B    'BGE     ',0
MESSAGE_BLT       DC.B    'BLT     ',0
MESSAGE_BGT       DC.B    'BGT     ',0
MESSAGE_BLE       DC.B    'BLE     ',0

MESSAGE_HEX         DC.B    '#$',0
MESSAGE_BYTE        DC.B    '.B    ',0
MESSAGE_WORD        DC.B    '.W    ',0
MESSAGE_LONG        DC.B    '.L    ',0
MESSAGE_DIRECTORY   DC.B    'D',0
MESSAGE_ADDRESS     DC.B    'A',0
MESSAGE_COMMA       DC.B    ',',0
MESSAGE_DATA        DC.B    'DATA:     ',0

CURRPAGE            EQU     $0
MESSAGE_CONTINUE    DC.B    'PLEASE HIT ANY KEY TO CONTINUE.',CR,LF,0

*----------------------Martin Variables--------------------------------
D DC.B    'D',0
A DC.B    'A',0
Bra DC.B   '(',0
NumSign DC.B '#',0
ABra DC.B   '(A',0
CloBra DC.B ')',0
PlusSign DC.B '+',0
NegSign DC.B '-',0
NEXTLINE DC.B CR,LF,0

LS DC.B    'LS',0
AS DC.B    'AS',0
RO DC.B    'RO',0
L DC.B    'L',0
R DC.B    'R',0
SizeB DC.B    '.B ',0
SizeW DC.B  '.W ',0
SizeL DC.B  '.L ',0
NUM DC.B '#',0
COMMA DC.B ' , ',0

SLASH DC.B '/',0

EA  DC.B    '<EA>',0
MESSAGE_MOVEM   DC.B  'MOVEM',0
TAP DC.B    '   ',0

dotw    DC.B    '.W',0
dotl    DC.B    '.L',0
MESSAGE_quit    DC.B    'PLEASE HIT ANY KEY quit.',CR,LF,0

    END    START        ; last line of source








*~Font name~Courier New~
*~Font size~10~
*~Tab type~1~
*~Tab size~4~
